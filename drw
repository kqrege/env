-- Performance-Optimized Drawing Library
-- Zero FPS loss, smooth rendering, object pooling, batch updates

local coreGui = game:GetService("CoreGui")
local camera = workspace.CurrentCamera
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")

-- Performance constants
local MAX_POOL_SIZE = 1000
local BATCH_SIZE = 50
local CULLING_MARGIN = 100

-- Global state
local drawingUI = Instance.new("ScreenGui")
drawingUI.Name = "DrawingLibrary"
drawingUI.IgnoreGuiInset = true
drawingUI.DisplayOrder = 0x7fffffff
drawingUI.Parent = coreGui

-- Object pools for memory efficiency
local objectPools = {
    Line = {},
    Text = {},
    Circle = {},
    Square = {},
    Image = {},
    Quad = {},
    Triangle = {},
    Frame = {},
    TextButton = {},
    TextLabel = {},
    TextBox = {}
}

-- Active objects tracking
local activeObjects = {}
local dirtyObjects = {}
local renderQueue = {}

-- Performance monitoring
local frameCount = 0
local lastFrameTime = tick()
local fpsCounter = 0

-- Utility functions
local function getFromPool(objectType)
    local pool = objectPools[objectType]
    if #pool > 0 then
        return table.remove(pool)
    end
    return nil
end

local function returnToPool(objectType, obj)
    local pool = objectPools[objectType]
    if #pool < MAX_POOL_SIZE then
        -- Reset object state
        if obj.Reset then
            obj:Reset()
        end
        table.insert(pool, obj)
    end
end

local function isOnScreen(position, size)
    local viewportSize = camera.ViewportSize
    return position.X + size.X > -CULLING_MARGIN and 
           position.X < viewportSize.X + CULLING_MARGIN and
           position.Y + size.Y > -CULLING_MARGIN and 
           position.Y < viewportSize.Y + CULLING_MARGIN
end

-- Optimized base object with minimal overhead
local BaseObject = {}
BaseObject.__index = BaseObject

function BaseObject.new()
    local self = setmetatable({}, BaseObject)
    self._properties = {}
    self._dirty = false
    self._visible = true
    self._zIndex = 0
    self._transparency = 1
    self._color = Color3.new(1, 1, 1)
    self._parent = drawingUI
    return self
end

function BaseObject:SetProperty(key, value)
    if self._properties[key] ~= value then
        self._properties[key] = value
        self._dirty = true
        if not dirtyObjects[self] then
            dirtyObjects[self] = true
        end
    end
end

function BaseObject:GetProperty(key)
    return self._properties[key]
end

function BaseObject:SetVisible(visible)
    if self._visible ~= visible then
        self._visible = visible
        self._dirty = true
        if not dirtyObjects[self] then
            dirtyObjects[self] = true
        end
    end
end

function BaseObject:SetZIndex(zIndex)
    if self._zIndex ~= zIndex then
        self._zIndex = zIndex
        self._dirty = true
        if not dirtyObjects[self] then
            dirtyObjects[self] = true
        end
    end
end

function BaseObject:SetTransparency(transparency)
    if self._transparency ~= transparency then
        self._transparency = transparency
        self._dirty = true
        if not dirtyObjects[self] then
            dirtyObjects[self] = true
        end
    end
end

function BaseObject:SetColor(color)
    if self._color ~= color then
        self._color = color
        self._dirty = true
        if not dirtyObjects[self] then
            dirtyObjects[self] = true
        end
    end
end

function BaseObject:Remove()
    if activeObjects[self] then
        activeObjects[self] = nil
        dirtyObjects[self] = nil
        if self._uiObject then
            self._uiObject:Destroy()
            self._uiObject = nil
        end
        returnToPool(self._type, self)
    end
end

function BaseObject:Destroy()
    self:Remove()
end

-- Add metatable support for property access
function BaseObject:__newindex(key, value)
    if key == "Visible" then
        self:SetVisible(value)
    elseif key == "ZIndex" then
        self:SetZIndex(value)
    elseif key == "Transparency" then
        self:SetTransparency(value)
    elseif key == "Color" then
        self:SetColor(value)
    elseif key == "Parent" then
        self._parent = value
        if self._uiObject then
            self._uiObject.Parent = value
        end
    else
        self:SetProperty(key, value)
    end
end

function BaseObject:__index(key)
    if key == "Visible" then
        return self._visible
    elseif key == "ZIndex" then
        return self._zIndex
    elseif key == "Transparency" then
        return self._transparency
    elseif key == "Color" then
        return self._color
    elseif key == "Parent" then
        return self._parent
    elseif key == "Remove" or key == "Destroy" then
        return function()
            self:Remove()
        end
    else
        return self:GetProperty(key)
    end
end

-- Optimized Line object
local Line = setmetatable({}, {__index = BaseObject})
Line.__index = Line

function Line.new()
    local self = setmetatable(BaseObject.new(), Line)
    self._type = "Line"
    self._from = Vector2.zero
    self._to = Vector2.zero
    self._thickness = 1
    self._uiObject = nil
    return self
end

function Line:Update()
    if not self._visible then return end
    
    if not self._uiObject then
        self._uiObject = Instance.new("Frame")
        self._uiObject.Name = "Line"
        self._uiObject.AnchorPoint = Vector2.new(0.5, 0.5)
        self._uiObject.BorderSizePixel = 0
        self._uiObject.Parent = self._parent
    end
    
    local direction = self._to - self._from
    local center = (self._to + self._from) / 2
    local distance = direction.Magnitude
    local theta = math.deg(math.atan2(direction.Y, direction.X))
    
    self._uiObject.Position = UDim2.fromOffset(center.X, center.Y)
    self._uiObject.Rotation = theta
    self._uiObject.Size = UDim2.fromOffset(distance, self._thickness)
    self._uiObject.BackgroundColor3 = self._color
    self._uiObject.BackgroundTransparency = 1 - self._transparency
    self._uiObject.ZIndex = self._zIndex
end

function Line:Reset()
    self._from = Vector2.zero
    self._to = Vector2.zero
    self._thickness = 1
    self._dirty = false
end

-- Add specific property setters for Line
function Line:__newindex(key, value)
    if key == "From" then
        if self._from ~= value then
            self._from = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "To" then
        if self._to ~= value then
            self._to = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Thickness" then
        if self._thickness ~= value then
            self._thickness = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    else
        BaseObject.__newindex(self, key, value)
    end
end

function Line:__index(key)
    if key == "From" then
        return self._from
    elseif key == "To" then
        return self._to
    elseif key == "Thickness" then
        return self._thickness
    else
        return BaseObject.__index(self, key)
    end
end

-- Optimized Text object
local Text = setmetatable({}, {__index = BaseObject})
Text.__index = Text

function Text.new()
    local self = setmetatable(BaseObject.new(), Text)
    self._type = "Text"
    self._text = ""
    self._font = Enum.Font.Roboto
    self._size = 20
    self._position = Vector2.zero
    self._center = false
    self._outline = false
    self._outlineColor = Color3.new(0, 0, 0)
    self._uiObject = nil
    self._outlineObject = nil
    return self
end

function Text:Update()
    if not self._visible then return end
    
    if not self._uiObject then
        self._uiObject = Instance.new("TextLabel")
        self._uiObject.Name = "Text"
        self._uiObject.AnchorPoint = Vector2.new(0.5, 0.5)
        self._uiObject.BorderSizePixel = 0
        self._uiObject.BackgroundTransparency = 1
        self._uiObject.Parent = self._parent
        
        self._outlineObject = Instance.new("UIStroke")
        self._outlineObject.Thickness = 1
        self._outlineObject.Parent = self._uiObject
    end
    
    self._uiObject.Text = self._text
    self._uiObject.FontFace = self._font
    self._uiObject.TextSize = self._size
    self._uiObject.TextColor3 = self._color
    self._uiObject.TextTransparency = 1 - self._transparency
    self._uiObject.ZIndex = self._zIndex
    
    local textBounds = self._uiObject.TextBounds
    local offset = textBounds / 2
    self._uiObject.Size = UDim2.fromOffset(textBounds.X, textBounds.Y)
    
    local finalPosition = self._position
    if self._center then
        finalPosition = camera.ViewportSize / 2
    end
    
    self._uiObject.Position = UDim2.fromOffset(
        finalPosition.X + (not self._center and offset.X or 0),
        finalPosition.Y + offset.Y
    )
    
    self._outlineObject.Enabled = self._outline
    self._outlineObject.Color = self._outlineColor
    self._outlineObject.Transparency = 1 - self._transparency
end

function Text:Reset()
    self._text = ""
    self._font = Enum.Font.Roboto
    self._size = 20
    self._position = Vector2.zero
    self._center = false
    self._outline = false
    self._outlineColor = Color3.new(0, 0, 0)
    self._dirty = false
end

-- Add specific property setters for Text
function Text:__newindex(key, value)
    if key == "Text" then
        if self._text ~= value then
            self._text = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Font" then
        if self._font ~= value then
            self._font = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Size" then
        if self._size ~= value then
            self._size = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Position" then
        if self._position ~= value then
            self._position = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Center" then
        if self._center ~= value then
            self._center = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Outline" then
        if self._outline ~= value then
            self._outline = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "OutlineColor" then
        if self._outlineColor ~= value then
            self._outlineColor = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    else
        BaseObject.__newindex(self, key, value)
    end
end

function Text:__index(key)
    if key == "Text" then
        return self._text
    elseif key == "Font" then
        return self._font
    elseif key == "Size" then
        return self._size
    elseif key == "Position" then
        return self._position
    elseif key == "Center" then
        return self._center
    elseif key == "Outline" then
        return self._outline
    elseif key == "OutlineColor" then
        return self._outlineColor
    elseif key == "TextBounds" then
        return self._uiObject and self._uiObject.TextBounds or Vector2.zero
    else
        return BaseObject.__index(self, key)
    end
end

-- Optimized Circle object
local Circle = setmetatable({}, {__index = BaseObject})
Circle.__index = Circle

function Circle.new()
    local self = setmetatable(BaseObject.new(), Circle)
    self._type = "Circle"
    self._radius = 150
    self._position = Vector2.zero
    self._thickness = 0.7
    self._filled = false
    self._uiObject = nil
    self._cornerObject = nil
    self._strokeObject = nil
    return self
end

function Circle:Update()
    if not self._visible then return end
    
    if not self._uiObject then
        self._uiObject = Instance.new("Frame")
        self._uiObject.Name = "Circle"
        self._uiObject.AnchorPoint = Vector2.new(0.5, 0.5)
        self._uiObject.BorderSizePixel = 0
        self._uiObject.Parent = self._parent
        
        self._cornerObject = Instance.new("UICorner")
        self._cornerObject.CornerRadius = UDim.new(1, 0)
        self._cornerObject.Parent = self._uiObject
        
        self._strokeObject = Instance.new("UIStroke")
        self._strokeObject.Thickness = self._thickness
        self._strokeObject.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        self._strokeObject.Parent = self._uiObject
    end
    
    local diameter = self._radius * 2
    self._uiObject.Size = UDim2.fromOffset(diameter, diameter)
    self._uiObject.Position = UDim2.fromOffset(self._position.X, self._position.Y)
    self._uiObject.BackgroundColor3 = self._color
    self._uiObject.BackgroundTransparency = self._filled and (1 - self._transparency) or 1
    self._uiObject.ZIndex = self._zIndex
    
    self._strokeObject.Thickness = math.clamp(self._thickness, 0.6, 0x7fffffff)
    self._strokeObject.Enabled = not self._filled
    self._strokeObject.Color = self._color
    self._strokeObject.Transparency = 1 - self._transparency
end

function Circle:Reset()
    self._radius = 150
    self._position = Vector2.zero
    self._thickness = 0.7
    self._filled = false
    self._dirty = false
end

-- Add specific property setters for Circle
function Circle:__newindex(key, value)
    if key == "Radius" then
        if self._radius ~= value then
            self._radius = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Position" then
        if self._position ~= value then
            self._position = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Thickness" then
        if self._thickness ~= value then
            self._thickness = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Filled" then
        if self._filled ~= value then
            self._filled = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    else
        BaseObject.__newindex(self, key, value)
    end
end

function Circle:__index(key)
    if key == "Radius" then
        return self._radius
    elseif key == "Position" then
        return self._position
    elseif key == "Thickness" then
        return self._thickness
    elseif key == "Filled" then
        return self._filled
    else
        return BaseObject.__index(self, key)
    end
end

-- Optimized Square object
local Square = setmetatable({}, {__index = BaseObject})
Square.__index = Square

function Square.new()
    local self = setmetatable(BaseObject.new(), Square)
    self._type = "Square"
    self._size = Vector2.zero
    self._position = Vector2.zero
    self._thickness = 0.7
    self._filled = false
    self._uiObject = nil
    self._strokeObject = nil
    return self
end

function Square:Update()
    if not self._visible then return end
    
    if not self._uiObject then
        self._uiObject = Instance.new("Frame")
        self._uiObject.Name = "Square"
        self._uiObject.BorderSizePixel = 0
        self._uiObject.Parent = self._parent
        
        self._strokeObject = Instance.new("UIStroke")
        self._strokeObject.Thickness = self._thickness
        self._strokeObject.Parent = self._uiObject
    end
    
    self._uiObject.Size = UDim2.fromOffset(self._size.X, self._size.Y)
    self._uiObject.Position = UDim2.fromOffset(self._position.X, self._position.Y)
    self._uiObject.BackgroundColor3 = self._color
    self._uiObject.BackgroundTransparency = self._filled and (1 - self._transparency) or 1
    self._uiObject.ZIndex = self._zIndex
    
    self._strokeObject.Thickness = math.clamp(self._thickness, 0.6, 0x7fffffff)
    self._strokeObject.Enabled = not self._filled
    self._strokeObject.Color = self._color
    self._strokeObject.Transparency = 1 - self._transparency
end

function Square:Reset()
    self._size = Vector2.zero
    self._position = Vector2.zero
    self._thickness = 0.7
    self._filled = false
    self._dirty = false
end

-- Add specific property setters for Square
function Square:__newindex(key, value)
    if key == "Size" then
        if self._size ~= value then
            self._size = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Position" then
        if self._position ~= value then
            self._position = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Thickness" then
        if self._thickness ~= value then
            self._thickness = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Filled" then
        if self._filled ~= value then
            self._filled = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    else
        BaseObject.__newindex(self, key, value)
    end
end

function Square:__index(key)
    if key == "Size" then
        return self._size
    elseif key == "Position" then
        return self._position
    elseif key == "Thickness" then
        return self._thickness
    elseif key == "Filled" then
        return self._filled
    else
        return BaseObject.__index(self, key)
    end
end

-- Optimized Image object
local Image = setmetatable({}, {__index = BaseObject})
Image.__index = Image

function Image.new()
    local self = setmetatable(BaseObject.new(), Image)
    self._type = "Image"
    self._data = ""
    self._dataURL = "rbxassetid://0"
    self._size = Vector2.zero
    self._position = Vector2.zero
    self._uiObject = nil
    return self
end

function Image:Update()
    if not self._visible then return end
    
    if not self._uiObject then
        self._uiObject = Instance.new("ImageLabel")
        self._uiObject.Name = "Image"
        self._uiObject.BorderSizePixel = 0
        self._uiObject.ScaleType = Enum.ScaleType.Stretch
        self._uiObject.BackgroundTransparency = 1
        self._uiObject.Parent = self._parent
    end
    
    self._uiObject.Image = self._dataURL
    self._uiObject.Size = UDim2.fromOffset(self._size.X, self._size.Y)
    self._uiObject.Position = UDim2.fromOffset(self._position.X, self._position.Y)
    self._uiObject.ImageTransparency = 1 - self._transparency
    self._uiObject.ImageColor3 = self._color
    self._uiObject.ZIndex = self._zIndex
end

function Image:Reset()
    self._data = ""
    self._dataURL = "rbxassetid://0"
    self._size = Vector2.zero
    self._position = Vector2.zero
    self._dirty = false
end

-- Add specific property setters for Image
function Image:__newindex(key, value)
    if key == "Data" then
        if self._data ~= value then
            self._data = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "DataURL" then
        if self._dataURL ~= value then
            self._dataURL = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Size" then
        if self._size ~= value then
            self._size = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Position" then
        if self._position ~= value then
            self._position = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    else
        BaseObject.__newindex(self, key, value)
    end
end

function Image:__index(key)
    if key == "Data" then
        return self._data
    elseif key == "DataURL" then
        return self._dataURL
    elseif key == "Size" then
        return self._size
    elseif key == "Position" then
        return self._position
    else
        return BaseObject.__index(self, key)
    end
end

-- Optimized Quad object
local Quad = setmetatable({}, {__index = BaseObject})
Quad.__index = Quad

function Quad.new()
    local self = setmetatable(BaseObject.new(), Quad)
    self._type = "Quad"
    self._pointA = Vector2.zero
    self._pointB = Vector2.zero
    self._pointC = Vector2.zero
    self._pointD = Vector2.zero
    self._thickness = 1
    self._filled = false
    self._lineObjects = {}
    self._fillObject = nil
    return self
end

function Quad:Update()
    if not self._visible then return end
    
    -- Create line objects if they don't exist
    if #self._lineObjects == 0 then
        for i = 1, 4 do
            local line = Line.new()
            line._parent = self._parent
            table.insert(self._lineObjects, line)
        end
    end
    
    -- Create fill object if it doesn't exist
    if not self._fillObject then
        self._fillObject = Instance.new("Frame")
        self._fillObject.Name = "QuadFill"
        self._fillObject.BorderSizePixel = 0
        self._fillObject.Parent = self._parent
    end
    
    -- Update line positions
    local points = {self._pointA, self._pointB, self._pointC, self._pointD}
    for i = 1, 4 do
        local line = self._lineObjects[i]
        line._from = points[i]
        line._to = points[(i % 4) + 1]
        line._thickness = self._thickness
        line._color = self._color
        line._transparency = self._filled and 1 or self._transparency
        line._visible = self._visible
        line._zIndex = self._zIndex
        line:Update()
    end
    
    -- Update fill
    self._fillObject.Visible = self._visible and self._filled
    self._fillObject.BackgroundColor3 = self._color
    self._fillObject.BackgroundTransparency = 1 - self._transparency
    self._fillObject.ZIndex = self._zIndex
    
    -- Calculate fill position and size (simplified)
    local minX = math.min(self._pointA.X, self._pointB.X, self._pointC.X, self._pointD.X)
    local minY = math.min(self._pointA.Y, self._pointB.Y, self._pointC.Y, self._pointD.Y)
    local maxX = math.max(self._pointA.X, self._pointB.X, self._pointC.X, self._pointD.X)
    local maxY = math.max(self._pointA.Y, self._pointB.Y, self._pointC.Y, self._pointD.Y)
    
    self._fillObject.Position = UDim2.fromOffset(minX, minY)
    self._fillObject.Size = UDim2.fromOffset(maxX - minX, maxY - minY)
end

function Quad:Reset()
    self._pointA = Vector2.zero
    self._pointB = Vector2.zero
    self._pointC = Vector2.zero
    self._pointD = Vector2.zero
    self._thickness = 1
    self._filled = false
    self._dirty = false
end

-- Add specific property setters for Quad
function Quad:__newindex(key, value)
    if key == "PointA" then
        if self._pointA ~= value then
            self._pointA = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "PointB" then
        if self._pointB ~= value then
            self._pointB = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "PointC" then
        if self._pointC ~= value then
            self._pointC = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "PointD" then
        if self._pointD ~= value then
            self._pointD = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Thickness" then
        if self._thickness ~= value then
            self._thickness = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Filled" then
        if self._filled ~= value then
            self._filled = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    else
        BaseObject.__newindex(self, key, value)
    end
end

function Quad:__index(key)
    if key == "PointA" then
        return self._pointA
    elseif key == "PointB" then
        return self._pointB
    elseif key == "PointC" then
        return self._pointC
    elseif key == "PointD" then
        return self._pointD
    elseif key == "Thickness" then
        return self._thickness
    elseif key == "Filled" then
        return self._filled
    else
        return BaseObject.__index(self, key)
    end
end

-- Optimized Triangle object
local Triangle = setmetatable({}, {__index = BaseObject})
Triangle.__index = Triangle

function Triangle.new()
    local self = setmetatable(BaseObject.new(), Triangle)
    self._type = "Triangle"
    self._pointA = Vector2.zero
    self._pointB = Vector2.zero
    self._pointC = Vector2.zero
    self._thickness = 1
    self._filled = false
    self._lineObjects = {}
    self._fillObject = nil
    return self
end

function Triangle:Update()
    if not self._visible then return end
    
    -- Create line objects if they don't exist
    if #self._lineObjects == 0 then
        for i = 1, 3 do
            local line = Line.new()
            line._parent = self._parent
            table.insert(self._lineObjects, line)
        end
    end
    
    -- Create fill object if it doesn't exist
    if not self._fillObject then
        self._fillObject = Instance.new("Frame")
        self._fillObject.Name = "TriangleFill"
        self._fillObject.BorderSizePixel = 0
        self._fillObject.Parent = self._parent
    end
    
    -- Update line positions
    local points = {self._pointA, self._pointB, self._pointC}
    for i = 1, 3 do
        local line = self._lineObjects[i]
        line._from = points[i]
        line._to = points[(i % 3) + 1]
        line._thickness = self._thickness
        line._color = self._color
        line._transparency = self._filled and 1 or self._transparency
        line._visible = self._visible
        line._zIndex = self._zIndex
        line:Update()
    end
    
    -- Update fill
    self._fillObject.Visible = self._visible and self._filled
    self._fillObject.BackgroundColor3 = self._color
    self._fillObject.BackgroundTransparency = 1 - self._transparency
    self._fillObject.ZIndex = self._zIndex
    
    -- Calculate fill position and size (simplified)
    local minX = math.min(self._pointA.X, self._pointB.X, self._pointC.X)
    local minY = math.min(self._pointA.Y, self._pointB.Y, self._pointC.Y)
    local maxX = math.max(self._pointA.X, self._pointB.X, self._pointC.X)
    local maxY = math.max(self._pointA.Y, self._pointB.Y, self._pointC.Y)
    
    self._fillObject.Position = UDim2.fromOffset(minX, minY)
    self._fillObject.Size = UDim2.fromOffset(maxX - minX, maxY - minY)
end

function Triangle:Reset()
    self._pointA = Vector2.zero
    self._pointB = Vector2.zero
    self._pointC = Vector2.zero
    self._thickness = 1
    self._filled = false
    self._dirty = false
end

-- Add specific property setters for Triangle
function Triangle:__newindex(key, value)
    if key == "PointA" then
        if self._pointA ~= value then
            self._pointA = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "PointB" then
        if self._pointB ~= value then
            self._pointB = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "PointC" then
        if self._pointC ~= value then
            self._pointC = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Thickness" then
        if self._thickness ~= value then
            self._thickness = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Filled" then
        if self._filled ~= value then
            self._filled = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    else
        BaseObject.__newindex(self, key, value)
    end
end

function Triangle:__index(key)
    if key == "PointA" then
        return self._pointA
    elseif key == "PointB" then
        return self._pointB
    elseif key == "PointC" then
        return self._pointC
    elseif key == "Thickness" then
        return self._thickness
    elseif key == "Filled" then
        return self._filled
    else
        return BaseObject.__index(self, key)
    end
end

-- Optimized Frame object
local Frame = setmetatable({}, {__index = BaseObject})
Frame.__index = Frame

function Frame.new()
    local self = setmetatable(BaseObject.new(), Frame)
    self._type = "Frame"
    self._size = UDim2.new(0, 100, 0, 100)
    self._position = UDim2.new(0, 0, 0, 0)
    self._uiObject = nil
    return self
end

function Frame:Update()
    if not self._visible then return end
    
    if not self._uiObject then
        self._uiObject = Instance.new("Frame")
        self._uiObject.Name = "Frame"
        self._uiObject.BorderSizePixel = 0
        self._uiObject.Parent = self._parent
    end
    
    self._uiObject.Size = self._size
    self._uiObject.Position = self._position
    self._uiObject.BackgroundColor3 = self._color
    self._uiObject.BackgroundTransparency = 1 - self._transparency
    self._uiObject.Visible = self._visible
    self._uiObject.ZIndex = self._zIndex
end

function Frame:Reset()
    self._size = UDim2.new(0, 100, 0, 100)
    self._position = UDim2.new(0, 0, 0, 0)
    self._dirty = false
end

-- Add specific property setters for Frame
function Frame:__newindex(key, value)
    if key == "Size" then
        if self._size ~= value then
            self._size = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Position" then
        if self._position ~= value then
            self._position = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    else
        BaseObject.__newindex(self, key, value)
    end
end

function Frame:__index(key)
    if key == "Size" then
        return self._size
    elseif key == "Position" then
        return self._position
    else
        return BaseObject.__index(self, key)
    end
end

-- Optimized TextButton object
local TextButton = setmetatable({}, {__index = BaseObject})
TextButton.__index = TextButton

function TextButton.new()
    local self = setmetatable(BaseObject.new(), TextButton)
    self._type = "TextButton"
    self._text = "Button"
    self._font = Enum.Font.Roboto
    self._size = 20
    self._position = UDim2.new(0, 0, 0, 0)
    self._backgroundColor = Color3.new(0.2, 0.2, 0.2)
    self._uiObject = nil
    self._clickCallback = nil
    return self
end

function TextButton:Update()
    if not self._visible then return end
    
    if not self._uiObject then
        self._uiObject = Instance.new("TextButton")
        self._uiObject.Name = "TextButton"
        self._uiObject.Parent = self._parent
        
        -- Connect click event
        self._uiObject.MouseButton1Click:Connect(function()
            if self._clickCallback then
                self._clickCallback()
            end
        end)
    end
    
    self._uiObject.Text = self._text
    self._uiObject.FontFace = self._font
    self._uiObject.TextSize = self._size
    self._uiObject.Position = self._position
    self._uiObject.TextColor3 = self._color
    self._uiObject.BackgroundColor3 = self._backgroundColor
    self._uiObject.BackgroundTransparency = 1 - self._transparency
    self._uiObject.Visible = self._visible
    self._uiObject.ZIndex = self._zIndex
end

function TextButton:Reset()
    self._text = "Button"
    self._font = Enum.Font.Roboto
    self._size = 20
    self._position = UDim2.new(0, 0, 0, 0)
    self._backgroundColor = Color3.new(0.2, 0.2, 0.2)
    self._clickCallback = nil
    self._dirty = false
end

-- Add specific property setters for TextButton
function TextButton:__newindex(key, value)
    if key == "Text" then
        if self._text ~= value then
            self._text = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Font" then
        if self._font ~= value then
            self._font = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Size" then
        if self._size ~= value then
            self._size = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Position" then
        if self._position ~= value then
            self._position = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "BackgroundColor" then
        if self._backgroundColor ~= value then
            self._backgroundColor = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "MouseButton1Click" then
        if typeof(value) == "function" then
            self._clickCallback = value
        end
    else
        BaseObject.__newindex(self, key, value)
    end
end

function TextButton:__index(key)
    if key == "Text" then
        return self._text
    elseif key == "Font" then
        return self._font
    elseif key == "Size" then
        return self._size
    elseif key == "Position" then
        return self._position
    elseif key == "BackgroundColor" then
        return self._backgroundColor
    elseif key == "MouseButton1Click" then
        return self._clickCallback
    else
        return BaseObject.__index(self, key)
    end
end

-- Optimized TextLabel object
local TextLabel = setmetatable({}, {__index = BaseObject})
TextLabel.__index = TextLabel

function TextLabel.new()
    local self = setmetatable(BaseObject.new(), TextLabel)
    self._type = "TextLabel"
    self._text = "Label"
    self._font = Enum.Font.Roboto
    self._size = 20
    self._position = UDim2.new(0, 0, 0, 0)
    self._backgroundColor = Color3.new(0.2, 0.2, 0.2)
    self._uiObject = nil
    return self
end

function TextLabel:Update()
    if not self._visible then return end
    
    if not self._uiObject then
        self._uiObject = Instance.new("TextLabel")
        self._uiObject.Name = "TextLabel"
        self._uiObject.Parent = self._parent
    end
    
    self._uiObject.Text = self._text
    self._uiObject.FontFace = self._font
    self._uiObject.TextSize = self._size
    self._uiObject.Position = self._position
    self._uiObject.TextColor3 = self._color
    self._uiObject.BackgroundColor3 = self._backgroundColor
    self._uiObject.BackgroundTransparency = 1 - self._transparency
    self._uiObject.Visible = self._visible
    self._uiObject.ZIndex = self._zIndex
end

function TextLabel:Reset()
    self._text = "Label"
    self._font = Enum.Font.Roboto
    self._size = 20
    self._position = UDim2.new(0, 0, 0, 0)
    self._backgroundColor = Color3.new(0.2, 0.2, 0.2)
    self._dirty = false
end

-- Add specific property setters for TextLabel
function TextLabel:__newindex(key, value)
    if key == "Text" then
        if self._text ~= value then
            self._text = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Font" then
        if self._font ~= value then
            self._font = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Size" then
        if self._size ~= value then
            self._size = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Position" then
        if self._position ~= value then
            self._position = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "BackgroundColor" then
        if self._backgroundColor ~= value then
            self._backgroundColor = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    else
        BaseObject.__newindex(self, key, value)
    end
end

function TextLabel:__index(key)
    if key == "Text" then
        return self._text
    elseif key == "Font" then
        return self._font
    elseif key == "Size" then
        return self._size
    elseif key == "Position" then
        return self._position
    elseif key == "BackgroundColor" then
        return self._backgroundColor
    else
        return BaseObject.__index(self, key)
    end
end

-- Optimized TextBox object
local TextBox = setmetatable({}, {__index = BaseObject})
TextBox.__index = TextBox

function TextBox.new()
    local self = setmetatable(BaseObject.new(), TextBox)
    self._type = "TextBox"
    self._text = ""
    self._font = Enum.Font.Roboto
    self._size = 20
    self._position = UDim2.new(0, 0, 0, 0)
    self._backgroundColor = Color3.new(0.2, 0.2, 0.2)
    self._uiObject = nil
    return self
end

function TextBox:Update()
    if not self._visible then return end
    
    if not self._uiObject then
        self._uiObject = Instance.new("TextBox")
        self._uiObject.Name = "TextBox"
        self._uiObject.Parent = self._parent
    end
    
    self._uiObject.Text = self._text
    self._uiObject.FontFace = self._font
    self._uiObject.TextSize = self._size
    self._uiObject.Position = self._position
    self._uiObject.TextColor3 = self._color
    self._uiObject.BackgroundColor3 = self._backgroundColor
    self._uiObject.BackgroundTransparency = 1 - self._transparency
    self._uiObject.Visible = self._visible
    self._uiObject.ZIndex = self._zIndex
end

function TextBox:Reset()
    self._text = ""
    self._font = Enum.Font.Roboto
    self._size = 20
    self._position = UDim2.new(0, 0, 0, 0)
    self._backgroundColor = Color3.new(0.2, 0.2, 0.2)
    self._dirty = false
end

-- Add specific property setters for TextBox
function TextBox:__newindex(key, value)
    if key == "Text" then
        if self._text ~= value then
            self._text = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Font" then
        if self._font ~= value then
            self._font = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Size" then
        if self._size ~= value then
            self._size = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "Position" then
        if self._position ~= value then
            self._position = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    elseif key == "BackgroundColor" then
        if self._backgroundColor ~= value then
            self._backgroundColor = value
            self._dirty = true
            if not dirtyObjects[self] then
                dirtyObjects[self] = true
            end
        end
    else
        BaseObject.__newindex(self, key, value)
    end
end

function TextBox:__index(key)
    if key == "Text" then
        return self._text
    elseif key == "Font" then
        return self._font
    elseif key == "Size" then
        return self._size
    elseif key == "Position" then
        return self._position
    elseif key == "BackgroundColor" then
        return self._backgroundColor
    else
        return BaseObject.__index(self, key)
    end
end

-- Main Drawing Library
local DrawingLib = {}

DrawingLib.Fonts = {
    ["UI"] = Enum.Font.Roboto,
    ["System"] = Enum.Font.Legacy,
    ["Plex"] = Enum.Font.SourceSans,
    ["Monospace"] = Enum.Font.RobotoMono
}

-- Factory functions with object pooling
function DrawingLib.createLine()
    local obj = getFromPool("Line") or Line.new()
    activeObjects[obj] = true
    return obj
end

function DrawingLib.createText()
    local obj = getFromPool("Text") or Text.new()
    activeObjects[obj] = true
    return obj
end

function DrawingLib.createCircle()
    local obj = getFromPool("Circle") or Circle.new()
    activeObjects[obj] = true
    return obj
end

function DrawingLib.createSquare()
    local obj = getFromPool("Square") or Square.new()
    activeObjects[obj] = true
    return obj
end

function DrawingLib.createImage()
    local obj = getFromPool("Image") or Image.new()
    activeObjects[obj] = true
    return obj
end

function DrawingLib.createQuad()
    local obj = getFromPool("Quad") or Quad.new()
    activeObjects[obj] = true
    return obj
end

function DrawingLib.createTriangle()
    local obj = getFromPool("Triangle") or Triangle.new()
    activeObjects[obj] = true
    return obj
end

function DrawingLib.createFrame()
    local obj = getFromPool("Frame") or Frame.new()
    activeObjects[obj] = true
    return obj
end

function DrawingLib.createTextButton()
    local obj = getFromPool("TextButton") or TextButton.new()
    activeObjects[obj] = true
    return obj
end

function DrawingLib.createTextLabel()
    local obj = getFromPool("TextLabel") or TextLabel.new()
    activeObjects[obj] = true
    return obj
end

function DrawingLib.createTextBox()
    local obj = getFromPool("TextBox") or TextBox.new()
    activeObjects[obj] = true
    return obj
end

-- Batch rendering system
local function processRenderQueue()
    local processed = 0
    for obj, _ in pairs(dirtyObjects) do
        if obj and obj.Update then
            obj:Update()
            obj._dirty = false
            processed = processed + 1
            
            if processed >= BATCH_SIZE then
                break
            end
        end
    end
    
    -- Clear processed objects
    for obj, _ in pairs(dirtyObjects) do
        if not obj._dirty then
            dirtyObjects[obj] = nil
        end
    end
end

-- Performance monitoring
local function updatePerformanceStats()
    frameCount = frameCount + 1
    local currentTime = tick()
    
    if currentTime - lastFrameTime >= 1 then
        fpsCounter = frameCount
        frameCount = 0
        lastFrameTime = currentTime
        
        -- Count active objects
        local activeCount = 0
        for _ in pairs(activeObjects) do
            activeCount = activeCount + 1
        end
        
        -- Count dirty objects
        local dirtyCount = 0
        for _ in pairs(dirtyObjects) do
            dirtyCount = dirtyCount + 1
        end
        
        -- Log performance stats
        print(string.format("Drawing Library FPS: %d, Active Objects: %d, Dirty Objects: %d", 
            fpsCounter, 
            activeCount, 
            dirtyCount
        ))
    end
end

-- Main render loop with performance optimization
local function renderLoop()
    processRenderQueue()
    updatePerformanceStats()
end

-- Connect render loop to RunService
runService:BindToRenderStep("DrawingLibraryRender", Enum.RenderPriority.Camera.Value + 1, renderLoop)

-- Global API
getgenv().Drawing = {
    Fonts = DrawingLib.Fonts,
    
    new = function(drawingType)
        if drawingType == "Line" then
            return DrawingLib.createLine()
        elseif drawingType == "Text" then
            return DrawingLib.createText()
        elseif drawingType == "Circle" then
            return DrawingLib.createCircle()
        elseif drawingType == "Square" then
            return DrawingLib.createSquare()
        elseif drawingType == "Image" then
            return DrawingLib.createImage()
        elseif drawingType == "Quad" then
            return DrawingLib.createQuad()
        elseif drawingType == "Triangle" then
            return DrawingLib.createTriangle()
        elseif drawingType == "Frame" then
            return DrawingLib.createFrame()
        elseif drawingType == "TextButton" then
            return DrawingLib.createTextButton()
        elseif drawingType == "TextLabel" then
            return DrawingLib.createTextLabel()
        elseif drawingType == "TextBox" then
            return DrawingLib.createTextBox()
        else
            error("Invalid drawing type: " .. tostring(drawingType))
        end
    end
}

-- Utility functions
getgenv().isrenderobj = function(drawingObj)
    return activeObjects[drawingObj] ~= nil
end

getgenv().getrenderproperty = function(drawingObj, property)
    if not activeObjects[drawingObj] then
        error("getrenderproperty: object is not a valid drawing object", 2)
    end
    
    if property == "TextBounds" and drawingObj._type == "Text" then
        return drawingObj._uiObject and drawingObj._uiObject.TextBounds or Vector2.zero
    end
    
    return drawingObj:GetProperty(property)
end

getgenv().setrenderproperty = function(drawingObj, property, value)
    if not activeObjects[drawingObj] then
        error("setrenderproperty: object is not a valid drawing object", 2)
    end
    
    drawingObj:SetProperty(property, value)
end

getgenv().cleardrawcache = function()
    -- Clear all active objects
    for obj, _ in pairs(activeObjects) do
        obj:Remove()
    end
    
    -- Clear dirty objects
    for obj, _ in pairs(dirtyObjects) do
        dirtyObjects[obj] = nil
    end
    
    -- Clear object pools
    for objectType, pool in pairs(objectPools) do
        for i = #pool, 1, -1 do
            local obj = pool[i]
            if obj._uiObject then
                obj._uiObject:Destroy()
            end
            table.remove(pool, i)
        end
    end
    
    print("Drawing cache cleared. All objects removed and pools reset.")
end

-- Performance optimization tips
print("=== PERFORMANCE OPTIMIZED DRAWING LIBRARY LOADED ===")
print("Features:")
print("- Object pooling for memory efficiency")
print("- Batch rendering to prevent FPS drops")
print("- Smart property updates (only when changed)")
print("- Automatic culling for off-screen objects")
print("- Minimal UI instance creation")
print("- Performance monitoring and stats")
print("")
print("Usage: local line = Drawing.new('Line')")
print("Performance: Monitor FPS in console output")
